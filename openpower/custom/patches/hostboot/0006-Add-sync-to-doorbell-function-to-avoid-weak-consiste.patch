From ecfddf368dfd6220a6536216d538e14bab7d570a Mon Sep 17 00:00:00 2001
From: Dan Crowell <dcrowell@us.ibm.com>
Date: Thu, 10 Jan 2019 13:40:32 -0600
Subject: [PATCH] Add sync to doorbell function to avoid weak consistency bug

Due to the way POWER works, there is no guarantee that a memory
location written by 1 thread is actually visible to another thread
unless you explicitly assert a sync of some kind.  In the code
that runs to wake up new cores, there is a path where memory
is written by 1 thread (usually on the master processor) but is
immediately consumed by a new thread that just woke up.  It is
possible for the new thread to consume the memory and not see
the contents that were written by the other thread.

The fix is to add a sync command before we send the doorbell
msgsnd operation.  This will ensure the memory contents are
visible to the thread as soon as it wakes up.

Change-Id: I8a1483dd7bbda5af064ba6d004dc9e0a3a61ce78
CQ: SW453195
Reviewed-on: http://rchgit01.rchland.ibm.com/gerrit1/70316
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Daniel M. Crowell <dcrowell@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/kernel/doorbell.C | 19 +++++++++++++++++--
 1 file changed, 17 insertions(+), 2 deletions(-)

diff --git a/src/kernel/doorbell.C b/src/kernel/doorbell.C
index 4b99e7aee..8f4175104 100644
--- a/src/kernel/doorbell.C
+++ b/src/kernel/doorbell.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2015,2016                        */
+/* Contributors Listed Below - COPYRIGHT 2015,2019                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -75,6 +75,10 @@ void send_doorbell_wakeup(uint64_t i_pir)
     // execution
     KernelWorkItem* l_work = new CpuWakeupDoorbellWorkItem();
     l_cpu->doorbell_actions.push(l_work);
+    //Put a barrier here to prevent a possible weak consistency
+    // issue with the l_work memory getting consumed incorrectly
+    // by the new thread that wakes up
+    sync();
     //Send doorbell to wakeup core/thread
     doorbell_send(i_pir);
 }
@@ -90,6 +94,17 @@ void send_doorbell_ipc(uint64_t i_pir)
     // execution (if needed, otherwise can likely delete and just send doorbell)
     KernelWorkItem* l_work = new IpcDoorbellWorkItem();
     l_cpu->doorbell_actions.push(l_work);
-    doorbell_send(i_pir)
+    //Put a barrier here to prevent a possible weak consistency
+    // issue with the l_work memory getting consumed incorrectly
+    // by the new thread that wakes up
+    sync();
+    //Send doorbell to wakeup core/thread
+    doorbell_send(i_pir);
+}
+
+void send_doorbell_ipc(uint64_t i_pir)
+{
+    printk("send_doorbell_ipc to pir: %lx\n", i_pir);
+    doorbell_send(i_pir);
 }
 **/
-- 
2.16.2.windows.1

