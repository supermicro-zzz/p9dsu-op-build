From 9e1f6c0234b17b5ac90caaf531a01862f5b4d915 Mon Sep 17 00:00:00 2001
From: Dan Crowell <dcrowell@us.ibm.com>
Date: Tue, 22 Jan 2019 15:32:10 -0600
Subject: [PATCH] Add retry to slave core wakeup path

We are still seeing some very intermittent errors in the slave
core wakeup path.  It still seems like we may have a timing issue.
Until we figure out exactly what is going on, I am adding a retry
mechanism that should get the core to report in correctly.  The
retry is done by issuing an additional doorbell message to the
core that didn't report in.

Change-Id: Ib87e5d58e079674d1eebb44c10d0252a35ea0519
---
 src/include/kernel/cpumgr.H                        | 11 ++++++-
 src/include/kernel/syscalls.H                      |  4 ++-
 src/include/sys/misc.h                             | 18 ++++++++++-
 src/kernel/cpumgr.C                                | 37 ++++++++++++++++++++--
 src/kernel/syscall.C                               | 11 +++++++
 src/lib/syscall_misc.C                             | 10 +++++-
 .../istep16/call_host_activate_slave_cores.C       | 17 +++++++++-
 7 files changed, 101 insertions(+), 7 deletions(-)

diff --git a/src/include/kernel/cpumgr.H b/src/include/kernel/cpumgr.H
index da669bd..c6695b8 100644
--- a/src/include/kernel/cpumgr.H
+++ b/src/include/kernel/cpumgr.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2010,2017                        */
+/* Contributors Listed Below - COPYRIGHT 2010,2019                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -146,6 +146,15 @@ class CpuManager
         static void startCore(uint64_t pir,uint64_t i_threads);
 
 
+        /** @fn wakeupCore
+         *  Start the core, can only be run after startCore.
+         *
+         *  @param[in] pir - PIR value of first thread in core.
+         *  @param[in] i_threads - Bitstring of threads to enable (left-justified).
+         */
+        static void wakeupCore(uint64_t pir,uint64_t i_threads);
+
+
         /** @fn forceMemoryPeriodic()
          * Force the memory free / coalesce operations to be performed on the
          * next "periodic" interval.
diff --git a/src/include/kernel/syscalls.H b/src/include/kernel/syscalls.H
index 951f55f..157b057 100644
--- a/src/include/kernel/syscalls.H
+++ b/src/include/kernel/syscalls.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2010,2014                        */
+/* Contributors Listed Below - COPYRIGHT 2010,2019                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -97,6 +97,8 @@ namespace Systemcalls
         MISC_CPUNAP,
             /** cpu_master_winkle() */
         MISC_CPUWINKLE,
+            /** cpu_wakeup_core() */
+        MISC_CPUWAKEUPCORE,
 
             /** mm_alloc_block() */
         MM_ALLOC_BLOCK,
diff --git a/src/include/sys/misc.h b/src/include/sys/misc.h
index cf8b6a9..52d6f9e 100644
--- a/src/include/sys/misc.h
+++ b/src/include/sys/misc.h
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2011,2017                        */
+/* Contributors Listed Below - COPYRIGHT 2011,2019                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -231,6 +231,22 @@ int cpu_master_winkle(bool  i_fusedCores);
  */
 int cpu_all_winkle();
 
+/** @fn cpu_wakeup_core
+ *  @brief Have the kernel wakeup a core that was previously started.
+ *
+ *  @param[in] pir - PIR value of the first thread on the core.
+ *  @param[in] i_threads - Bitstring of threads to enable (left-justified).
+ *
+ *  @note The kernel will wakeup all threads on the requested core even
+ *        though the callee only requests with a single PIR value.
+ *
+ *  @return 0 or -(errno) on failure.
+ *
+ *  @retval -ENXIO - The core ID was outside of the range the kernel is
+ *                   prepared to support.
+ */
+int cpu_wakeup_core(uint64_t pir,uint64_t i_threads);
+
 /** @fn cpu_crit_assert
  *  @brief Forces a Terminate Immediate after a crit-assert is issued
  *  @param[in] i_failAddr - value in the linkRegister of the address
diff --git a/src/kernel/cpumgr.C b/src/kernel/cpumgr.C
index 2469ad3..c0f364e 100644
--- a/src/kernel/cpumgr.C
+++ b/src/kernel/cpumgr.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2010,2017                        */
+/* Contributors Listed Below - COPYRIGHT 2010,2019                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -446,7 +446,7 @@ void CpuManager::startCore(uint64_t pir,uint64_t i_threads)
         // Only wakeup the threads we were told to wakeup
         if( i_threads & (0x8000000000000000 >> i) )
         {
-            printk("Dbell wkup pir %ld\n", pir + i);
+            printk("Dbell:0x%lx\n", pir + i);
             //Initiate the Doorbell for this core/pir
             send_doorbell_wakeup(pir + i);
         }
@@ -455,6 +455,39 @@ void CpuManager::startCore(uint64_t pir,uint64_t i_threads)
     return;
 };
 
+void CpuManager::wakeupCore(uint64_t pir,uint64_t i_threads)
+{
+    size_t threads = getThreadCount();
+    pir = pir & ~(threads-1);
+
+    if (pir >=
+        (KERNEL_MAX_SUPPORTED_NODES * KERNEL_MAX_SUPPORTED_CPUS_PER_NODE))
+    {
+        TASK_SETRTN(TaskManager::getCurrentTask(), -ENXIO);
+        return;
+    }
+
+    //Send a message to userspace that a core with this base pir is being added
+    // userspace will know which threads on the core to expect already
+    InterruptMsgHdlr::addCpuCore(pir);
+
+    // Physically wakeup the threads with doorbells
+    //  Assumption is that startCore has already run so all
+    //  internal structures are setup
+    for(size_t i = 0; i < threads; i++)
+    {
+        // Only wakeup the threads we were told to wakeup
+        if( i_threads & (0x8000000000000000 >> i) )
+        {
+            printk("Dbell2:0x%lx\n", pir + i);
+            //Initiate the Doorbell for this core/pir
+            doorbell_send(pir + i);
+        }
+    }
+
+    return;
+};
+
 size_t CpuManager::getThreadCount()
 {
     size_t threads = 0;
diff --git a/src/kernel/syscall.C b/src/kernel/syscall.C
index 50add66..965f2ef 100644
--- a/src/kernel/syscall.C
+++ b/src/kernel/syscall.C
@@ -54,6 +54,8 @@ namespace KernelIpc
 extern "C"
 void kernel_execute_hype_doorbell()
 {
+    printkd("hyp_doorbell on %lx\n", getPIR());
+
     // Per POWER ISA Section 5.9.2, to avoid any weak consistency
     //  issues we must use a msgsync instruction before consuming
     //  any data set by a different thread following a doorbell
@@ -127,6 +129,7 @@ namespace Systemcalls
     void CpuSprValue(task_t *t);
     void CpuNap(task_t *t);
     void CpuWinkle(task_t *t);
+    void CpuWakeupCore(task_t *t);
     void MmAllocBlock(task_t *t);
     void MmRemovePages(task_t *t);
     void MmSetPermission(task_t *t);
@@ -168,6 +171,7 @@ namespace Systemcalls
         &CpuSprValue, // MISC_CPUSPRVALUE
         &CpuNap, // MISC_CPUNAP
         &CpuWinkle,   // MISC_CPUWINKLE
+        &CpuWakeupCore,   // MISC_CPUWAKEUPCORE
 
         &MmAllocBlock, // MM_ALLOC_BLOCK
         &MmRemovePages, // MM_REMOVE_PAGES
@@ -807,6 +811,13 @@ namespace Systemcalls
         }
     }
 
+    /** Force thread wakeup via doorbell. */
+    void CpuWakeupCore(task_t *t)
+    {
+        CpuManager::wakeupCore(static_cast<uint64_t>(TASK_GETARG0(t)),
+                               static_cast<uint64_t>(TASK_GETARG1(t)));
+    };
+
     /**
      * Allocate a block of virtual memory within the base segment
      * @param[in] t: The task used to allocate a block in the base segment
diff --git a/src/lib/syscall_misc.C b/src/lib/syscall_misc.C
index fd8d76b..de58c44 100644
--- a/src/lib/syscall_misc.C
+++ b/src/lib/syscall_misc.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2011,2017                        */
+/* Contributors Listed Below - COPYRIGHT 2011,2019                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -124,6 +124,14 @@ int cpu_all_winkle()
     return rc;
 }
 
+int cpu_wakeup_core(uint64_t pir,uint64_t i_threads)
+{
+    return reinterpret_cast<int64_t>(
+        _syscall2(MISC_CPUWAKEUPCORE,
+                  reinterpret_cast<void*>(pir),
+                  reinterpret_cast<void*>(i_threads)));
+}
+
 
 void cpu_crit_assert(uint64_t i_failAddr)
 {
diff --git a/src/usr/isteps/istep16/call_host_activate_slave_cores.C b/src/usr/isteps/istep16/call_host_activate_slave_cores.C
index a6bff19..3056277 100644
--- a/src/usr/isteps/istep16/call_host_activate_slave_cores.C
+++ b/src/usr/isteps/istep16/call_host_activate_slave_cores.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2015,2017                        */
+/* Contributors Listed Below - COPYRIGHT 2015,2019                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -121,6 +121,18 @@ void* call_host_activate_slave_cores (void *io_pArgs)
 
             int rc = cpu_start_core(pir, en_threads);
 
+            // Workaround to handle some syncing issues with new cpus
+            //  waking
+            if (-ETIME == rc)
+            {
+                TRACFCOMP( ISTEPS_TRACE::g_trac_isteps_trace,
+                        "call_host_activate_slave_cores: "
+                        "Time out rc from kernel %d on core 0x%x, resending doorbell",
+                        rc,
+                        pir);
+                rc = cpu_wakeup_core(pir,en_threads);
+            }
+
             // Handle time out error
             if (-ETIME == rc)
             {
@@ -220,6 +232,9 @@ void* call_host_activate_slave_cores (void *io_pArgs)
 
                 ErrlUserDetailsTarget(*l_core).addToLog( l_errl );
 
+                // Add interesting ISTEP traces
+                l_errl->collectTrace(ISTEP_COMP_NAME,256);
+
                 // Create IStep error log and cross ref error that
                 // occurred
                 l_stepError.addErrorDetails( l_errl );
-- 
1.8.2.2

